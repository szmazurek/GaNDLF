#!usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function, division
import os, argparse, ast
from GANDLF.utils import fix_paths
fix_paths(os.getcwd())  # add relevant vips path

from datetime import date

from GANDLF import version
from GANDLF.cli.main_run import main_run


if __name__ == "__main__":
    copyrightMessage = (
        "Contact: gandlf@cbica.upenn.edu\n\n"
        + "This program is NOT FDA/CE approved and NOT intended for clinical use.\nCopyright (c) "
        + str(date.today().year)
        + " University of Pennsylvania. All rights reserved.\n\nCitation: https://arxiv.org/abs/2103.01006"
    )
    parser = argparse.ArgumentParser(
        prog="GANDLF",
        formatter_class=argparse.RawTextHelpFormatter,
        description="Semantic segmentation, regression, and classification for medical images using Deep Learning.\n\n"
        + copyrightMessage,
    )
    parser.add_argument(
        "-config",
        type=str,
        help="The configuration file (contains all the information related to the training/inference session)",
        required=True,
    )
    parser.add_argument(
        "-data",
        type=str,
        help="Data CSV file that is used for training/inference; can also take comma-separated training-validatation pre-split CSVs",
        required=True,
    )
    parser.add_argument(
        "-train",
        type=ast.literal_eval,
        help="True: training and False: inference; for inference, there needs to be a compatible model saved in '-output'",
        required=True,
    )
    parser.add_argument(
        "-output",
        type=str,
        help="Training: Output directory to save intermediate files and model weights; inference: location of previous training session output",
        required=True,
    )
    parser.add_argument(
        "-device",
        default="cuda",
        type=str,
        help="Device to perform requested session on 'cpu' or 'cuda'; for cuda, ensure CUDA_VISIBLE_DEVICES env var is set",
        required=True,
    )
    parser.add_argument(
        "-reset_prv",
        default=False,
        type=ast.literal_eval,
        help="Whether the previous run in the output directory will be discarded or not",
        required=False,
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version="%(prog)s v{}".format(version) + "\n\n" + copyrightMessage,
        help="Show program's version number and exit.",
    )

    args = parser.parse_args()

    # ## one_hot testing
    # import SimpleITK as sitk
    # import torch
    # from GANDLF.utils import one_hot, reverse_one_hot, resize_image

    # file="C:/Users/sarth/Downloads/debug_lits/0_label.nii.gz"
    # class_list = [0,"1||2"]
    # file_path = os.path.dirname(os.path.abspath(file))
    # img = sitk.ReadImage(file)
    # # img_resize = resize_image(img, (256, 256))
    # # sitk.WriteImage(img_resize,"C:/Users/sarth/Downloads/vinny_debug/resize.nii.gz")
    # img_tensor = torch.from_numpy(sitk.GetArrayFromImage(img)).to(torch.float16)
    # img_tensor = img_tensor.unsqueeze(0)
    # img_tensor = img_tensor.unsqueeze(0)
    # img_tensor_oh = one_hot(img_tensor, class_list)
    # img_tensor_oh_rev = reverse_one_hot(img_tensor_oh[0], class_list)
    # for i in range(img_tensor_oh.shape[1]):
    #     curr_img = sitk.GetImageFromArray(img_tensor_oh[0,i,...].numpy())
    #     curr_img = sitk.Cast(curr_img, sitk.sitkInt16)
    #     curr_img.CopyInformation(img)
    #     sitk.WriteImage(curr_img, os.path.join(file_path,"seg_oh_"+str(i)+".nii.gz"))
    # curr_img = sitk.GetImageFromArray(img_tensor_oh_rev)
    # curr_img = sitk.Cast(curr_img, sitk.sitkInt16)
    # curr_img.CopyInformation(img)
    # sitk.WriteImage(curr_img, os.path.join(file_path,"seg_oh_rev.nii.gz"))
    # ## one_hot testing

    ### unit testing
    from testing.test_full import test_config_read, test_augmentation_functions, test_cli_function_preprocess, test_cli_function_mainrun, test_preprocess_functions, test_metrics_segmentation_rad_2d, test_inference_classification_rad_3d, test_train_segmentation_rad_3d, test_train_segmentation_rad_2d, test_train_classification_rad_2d, test_train_regression_rad_2d, test_dataloader_construction_train_segmentation_3d, test_model_patch_divisibility, test_checkpointing_segmentation_rad_2d, test_losses_segmentation_rad_2d, test_one_hot_logic, test_train_segmentation_sdnet_rad_2d
    # from testing.test_full import test_losses_regression_rad_2d
    # test_losses_regression_rad_2d("cuda")
    
    # test_model_patch_divisibility()
    # test_config_read()
    # test_cli_function_preprocess()
    # test_cli_function_mainrun("cuda")
    # test_preprocess_functions()
    # test_augmentation_functions()
    # test_metrics_segmentation_rad_2d("cuda")
    # test_inference_classification_rad_3d("cuda")
    # test_train_classification_rad_2d("cuda")
    # test_train_regression_rad_2d("cuda")
    # test_dataloader_construction_train_segmentation_3d("cuda")
    # test_one_hot_logic()
    # test_train_segmentation_rad_3d("cuda")
    test_train_segmentation_rad_2d("cuda")
    # test_checkpointing_segmentation_rad_2d("cuda")
    # test_losses_segmentation_rad_2d("cuda")
    # test_train_segmentation_sdnet_rad_2d("cuda")
    ### unit testing

    main_run(
        args.data, args.config, args.output, args.train, args.device, args.reset_prv
    )

    print("Finished.")
