#!usr/bin/env python
# -*- coding: utf-8 -*-

import os, argparse
from pathlib import Path
from datetime import date
import numpy as np

from GANDLF.utils import parseTrainingCSV
from GANDLF.parseConfig import parseConfig

import torchio

def main():
  copyrightMessage = 'Contact: software@cbica.upenn.edu\n\n' + 'This program is NOT FDA/CE approved and NOT intended for clinical use.\nCopyright (c) ' + str(date.today().year) + ' University of Pennsylvania. All rights reserved.' 

  parser = argparse.ArgumentParser(prog='GANDLF_Padder', formatter_class=argparse.RawTextHelpFormatter, description = "Generate training/inference data which are padded.\n\n" + copyrightMessage)
  parser.add_argument('-config', type=str, help = 'The configuration file (contains all the information related to the training/inference session), this is read from \'output\' during inference', required=True)
  parser.add_argument('-data', type=str, help = 'Data csv file that is used for training/inference; can also take a comma-separate training-validatation pre-split CSV', required=True)
  parser.add_argument('-output', type=str, help = 'Output directory to save intermediate files and model weights', required=True)
      
  args = parser.parse_args()

  Path(args.output).mkdir(parents=True, exist_ok=True)

  # read the csv
  dataframe, headers = parseTrainingCSV(args.data, train=False) # don't care if the dataframe gets shuffled or not
  parameters = parseConfig(args.config)

  # csv headers
  channelHeaders = headers['channelHeaders']
  labelHeader = headers['labelHeader']
  predictionHeaders = headers['predictionHeaders']
  subjectIDHeader = headers['subjectIDHeader']
  psize = parameters['psize']
  
  num_row, num_col = dataframe.shape
  dataframe.columns = range(0,num_col)
  dataframe.index = range(0,num_row)
  subjects_list = []

  for patient in range(num_row):
    # We need this dict for storing the meta data for each subject
    # such as different image modalities, labels, any other data
    subject_dict = {}
    subject_dict['subject_id'] = dataframe[subjectIDHeader][patient]
    skip_subject = False
    # iterating through the channels/modalities/timepoints of the subject
    for channel in channelHeaders:
      # sanity check for malformed csv
      if not os.path.isfile(str(dataframe[channel][patient])):
          skip_subject = True
      # assigning the dict key to the channel
      subject_dict[str(channel)] = torchio.Image(str(dataframe[channel][patient]), type=torchio.INTENSITY)

    if labelHeader is not None:
      if not os.path.isfile(str(dataframe[labelHeader][patient])):
          skip_subject = True
      subject_dict['label'] = torchio.Image(str(dataframe[labelHeader][patient]), type=torchio.LABEL)

    # skip subject the condition was tripped
    if not skip_subject:
      # Initializing the subject object using the dict
      subject = torchio.Subject(subject_dict)
  
      psize_pad = list(np.asarray(np.ceil(np.divide(psize,2)), dtype=int))
      padder = torchio.transforms.Pad(psize_pad, padding_mode = 'symmetric') # for modes: https://numpy.org/doc/stable/reference/generated/numpy.pad.html
      subject = padder(subject)

    for key in subject:
      print(subject[key]['path'])

# main function
if __name__ == '__main__':
  main()
