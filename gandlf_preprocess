#!usr/bin/env python
# -*- coding: utf-8 -*-

import os, argparse, sys
from pathlib import Path
from datetime import date
import numpy as np
import SimpleITK as sitk

from GANDLF.utils import (
    parseTrainingCSV,
    populate_header_in_parameters,
    get_filename_extension_sanitized,
)
from GANDLF.parseConfig import parseConfig
from GANDLF.data.ImagesFromDataFrame import global_preprocessing_dict
from GANDLF.data.ImagesFromDataFrame import ImagesFromDataFrame
from torch.utils.data import DataLoader
from tqdm import tqdm

import torchio


def main():
    copyrightMessage = (
        "Contact: software@cbica.upenn.edu\n\n"
        + "This program is NOT FDA/CE approved and NOT intended for clinical use.\nCopyright (c) "
        + str(date.today().year)
        + " University of Pennsylvania. All rights reserved."
    )

    parser = argparse.ArgumentParser(
        prog="GANDLF_Preprocess",
        formatter_class=argparse.RawTextHelpFormatter,
        description="Generate training/inference data which are preprocessed to reduce resource footprint during computation.\n\n"
        + copyrightMessage,
    )
    parser.add_argument(
        "-config",
        type=str,
        help="The configuration file (contains all the information related to the training/inference session), this is read from 'output' during inference",
        required=True,
    )
    parser.add_argument(
        "-data",
        type=str,
        help="Data csv file that is used for training/inference; can also take a comma-separate training-validatation pre-split CSV",
        required=True,
    )
    parser.add_argument(
        "-output",
        type=str,
        help="Output directory to save intermediate files and model weights",
        required=True,
    )
    parser.add_argument(
        "-labelPad",
        type=str,
        default="constant",
        help="This specifies the padding strategy for the label when 'patch_sampler' is 'label'. Defaults to 'constant' [full list: https://numpy.org/doc/stable/reference/generated/numpy.pad.html]",
        required=False,
    )

    args = parser.parse_args()

    Path(args.output).mkdir(parents=True, exist_ok=True)

    # read the csv
    # don't care if the dataframe gets shuffled or not
    dataframe, headers = parseTrainingCSV(args.data, train=False)
    parameters = parseConfig(args.config)
    parameters = populate_header_in_parameters(parameters, headers)

    data_for_processing = ImagesFromDataFrame(dataframe, parameters, train=False)

    dataloader_for_processing = DataLoader(
        data_for_processing,
        batch_size=1,
        pin_memory=False,
    )

    ## to-do
    # use dataloader_for_processing to loop through all images
    # if padding is enabled, ensure that it gets applied to the images
    # save the images to disk, but keep a record that these images are preprocessed.
    # create new csv that contains new files.

    for _, (subject) in enumerate(
        tqdm(dataloader_for_processing, desc="Looping over data")
    ):
        subject_dict_to_write = {}
        subject_dict_label = {}

        current_output_dir = os.path.join(args.output, str(subject["subject_id"][0]))
        Path(current_output_dir).mkdir(parents=True, exist_ok=True)

        # the "squeeze" is needed because the dataloader automatically constructs
        # 5D tensor considering the batch_size as first dimension.
        for key in parameters["headers"]["channelHeaders"]:
            # apply a different padding mode to image and label (so that label information is not duplicated)
            psize_pad = list(np.asarray(np.ceil(np.divide(parameters["psize"], 2)), dtype=int))
            # for modes: https://numpy.org/doc/stable/reference/generated/numpy.pad.html
            padder = torchio.transforms.Pad(psize_pad, padding_mode="symmetric")
            subject = padder(subject)

        if parameters["headers"["labelHeader"]] is not None:
            subject_dict_label["label"] = torchio.Image(
                str(subject["label"]["path"]), type=torchio.LABEL
            )
            subject_label = torchio.Subject(subject_dict_label)
            # for modes: https://numpy.org/doc/stable/reference/generated/numpy.pad.html
            padder_label = torchio.transforms.Pad(
                psize_pad, padding_mode=args.labelPad
            )
            subject_label = padder_label(subject_label)

            # now combine the label with the original subject dictionary to do sampling
            subject["label"] = subject_label["label"]

            sampler = torchio.data.LabelSampler(parameters["psize"])
            generator = sampler(subject, num_patches=1)
            for patch in generator:
                for channel in parameters["headers"]["channelHeaders"]:
                    subject_dict_to_write[str(channel)] = patch[str(channel)]

                subject_dict_to_write["label"] = patch["label"]
        else:
            subject_dict_to_write = subject

        # write new images
        for key in parameters["headers"]["channelHeaders"]:
            pth = Path(subject_dict_to_write[str(key)]["path"])
            image_file = os.path.join(current_output_dir, pth.name)
            image_to_write = subject_dict_to_write[str(key)].as_sitk()
            if not os.path.isfile(image_file):
                try:
                    sitk.WriteImage(image_to_write, image_file)
                except IOError:
                    IOError(
                        "Could not write image file: {}. Make sure that the file is not open and try again.".format(
                            image_file
                        )
                    )
                    sys.exit(1)

        # now try to write the label
        if "label" in subject_dict_to_write:
            pth = Path(subject_dict_to_write["label"]["path"])
            image_file = os.path.join(current_output_dir, pth.name)
            image_to_write = subject_dict_to_write["label"].as_sitk()
            if not os.path.isfile(image_file):
                try:
                    sitk.WriteImage(image_to_write, image_file)
                except IOError:
                    IOError(
                        "Could not write image file: {}. Make sure that the file is not open and try again.".format(
                            image_file
                        )
                    )
                    sys.exit(1)


# main function
if __name__ == "__main__":
    main()
